use crate::{
    io::Buf,
    mariadb::{
        io::BufExt,
        protocol::{ColumnDefinitionPacket, FieldType},
    },
};
use byteorder::LittleEndian;
use std::{io, pin::Pin, ptr::NonNull};

/// A resultset row represents a database resultset unit, which is usually generated by
/// executing a statement that queries the database.
#[derive(Debug)]
pub struct ResultRow {
    #[used]
    buffer: Pin<Box<[u8]>>,
    pub values: Box<[Option<NonNull<[u8]>>]>,
}

// SAFE: Raw pointers point to pinned memory inside the struct
unsafe impl Send for ResultRow {}
unsafe impl Sync for ResultRow {}

impl ResultRow {
    pub fn decode(mut buf: &[u8], columns: &[ColumnDefinitionPacket]) -> io::Result<Self> {
        // 0x00 header : byte<1>
        let header = buf.get_u8()?;
        // TODO: Replace with InvalidData err
        debug_assert_eq!(header, 0);

        // NULL-Bitmap : byte<(number_of_columns + 9) / 8>
        let null = buf.get_uint::<LittleEndian>((columns.len() + 9) / 8)?;

        let buffer: Pin<Box<[u8]>> = Pin::new(buf.into());
        let mut buf = &*buffer;

        let mut values = Vec::with_capacity(columns.len());

        for column_idx in 0..columns.len() {
            if (null & (1 << column_idx)) != 0 {
                values.push(None);
            } else {
                match columns[column_idx].field_type {
                    FieldType::MYSQL_TYPE_LONG => {
                        values.push(Some(buf[..(4 as usize)].into()));
                        buf.advance(4);
                    }

                    FieldType::MYSQL_TYPE_VAR_STRING => {
                        let len = buf.get_uint_lenenc::<LittleEndian>()?.unwrap_or_default();

                        values.push(Some(buf[..(len as usize)].into()));
                        buf.advance(len as usize);
                    }

                    type_ => {
                        unimplemented!("encountered unknown field type: {:?}", type_);
                    }
                }
            }
        }

        Ok(Self {
            buffer,
            values: values.into_boxed_slice(),
        })
    }
}
