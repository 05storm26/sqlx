use crate::{
    io::Buf,
    mariadb::{
        io::BufExt,
        protocol::{ColumnDefinitionPacket, FieldType},
    },
};
use byteorder::LittleEndian;
use std::{io, pin::Pin, ptr::NonNull};

/// A resultset row represents a database resultset unit, which is usually generated by
/// executing a statement that queries the database.
#[derive(Debug)]
pub struct ResultRow {
    #[used]
    buffer: Pin<Box<[u8]>>,
    pub values: Box<[Option<NonNull<[u8]>>]>,
}

// SAFE: Raw pointers point to pinned memory inside the struct
unsafe impl Send for ResultRow {}
unsafe impl Sync for ResultRow {}

impl ResultRow {
    pub fn decode(mut buf: &[u8], columns: &[ColumnDefinitionPacket]) -> crate::Result<Self> {
        // 0x00 header : byte<1>
        let header = buf.get_u8()?;

        if header != 0 {
            return Err(protocol_err!("expected header 0x00, got: {:#04X}", header).into());
        }

        // NULL-Bitmap : byte<(number_of_columns + 9) / 8>
        let null_len = (columns.len() + 9) / 8;
        let null = &buf[..];
        buf.advance(null_len);

        let buffer: Pin<Box<[u8]>> = Pin::new(buf.into());
        let mut buf = &*buffer;

        let mut values = Vec::with_capacity(columns.len());

        for column_idx in 0..columns.len() {
            if null[column_idx / 8] & (1 << (column_idx % 8)) != 0 {
                values.push(None);
            } else {
                match columns[column_idx].field_type {
                    FieldType::MYSQL_TYPE_LONG => {
                        values.push(Some(buf.get_bytes(4)?.into()));
                    }

                    FieldType::MYSQL_TYPE_TINY_BLOB
                    | FieldType::MYSQL_TYPE_MEDIUM_BLOB
                    | FieldType::MYSQL_TYPE_LONG_BLOB
                    | FieldType::MYSQL_TYPE_BLOB
                    | FieldType::MYSQL_TYPE_GEOMETRY
                    | FieldType::MYSQL_TYPE_STRING
                    | FieldType::MYSQL_TYPE_VARCHAR
                    | FieldType::MYSQL_TYPE_VAR_STRING => {
                        values.push(buf.get_bytes_lenenc::<LittleEndian>()?.map(Into::into));
                    }

                    type_ => {
                        unimplemented!("encountered unknown field type: {:?}", type_);
                    }
                }
            }
        }

        Ok(Self {
            buffer,
            values: values.into_boxed_slice(),
        })
    }
}
